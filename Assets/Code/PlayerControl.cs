using System;
using UnityEngine;
using UnityEngine.UI;

/// <summary>
/// Control code for the the player's game object.
/// Very approximate simulation of flight dynamics.
/// </summary>
public class PlayerControl : MonoBehaviour
{
    [Header("Gun variables")]
    /// <summary>
    /// Cooldown period between shots
    /// </summary>
    public float GunCoolDownTime;

    /// <summary>
    /// Prefab of a bullet
    /// </summary>
    public GameObject BulletPrefab;


    /// <summary>
    /// Velocity of fired bullets
    /// </summary>
    public float BulletVelocity;

    /// <summary>
    /// Coefficient of draft for head winds
    /// </summary>
    [Header("Aerodynamic coefficients")]
    public float ForwardDragCoefficient = 0.01f;
    /// <summary>
    /// Drag coefficient for winds blowing up/down across wings
    /// </summary>
    public float VerticalDragCoefficient = 0.5f;
    /// <summary>
    /// Lift generated by the wings
    /// </summary>
    public float LiftCoefficient = 0.01f;

    /// <summary>
    /// How far the plane can tilt around the X axis
    /// </summary>
    [Header("Movement Speeds")]
    public float PitchRange = 45f;
    /// <summary>
    /// How far the plane can rotate about the Z axis
    /// </summary>
    public float RollRange = 45;
    /// <summary>
    /// How fast the plane yaws for a given degree of roll.
    /// </summary>
    public float RotationalSpeed = 5f;
    /// <summary>
    /// Thrust generated when the throttle is pulled back all the way.
    /// </summary>
    public float MaximumThrust = 20f;
    /// <summary>
    /// Weight of Lerp for roll and pitch controls.
    /// </summary>
    public float LerpWeight = 0.01f;

    /// <summary>
    /// Text element for displaying status information
    /// </summary>
    [Header("HUD")]
    public Text StatusDisplay;
    /// <summary>
    /// Text element for displaying game-over text
    /// </summary>
    public Text GameOverText;

    /// <summary>
    /// Cached copy of the player's RigidBody component
    /// </summary>
    private Rigidbody playerRB;


    /// <summary>
    /// Magic layer mask code for the updraft(s)
    /// </summary>
    const int UpdraftLayerMask = 1 << 8;


    #region Internal flight state
    /// <summary>
    /// Current yaw (rotation about the Y axis)
    /// </summary>
    private float yaw;
    /// <summary>
    /// Current pitch (rotation about the X axis)
    /// </summary>
    private float pitch;
    /// <summary>
    /// Current roll (rotation about the Z axis)
    /// </summary>
    private float roll;
    /// <summary>
    /// Current thrust (forward force provided by engines)
    /// </summary>
    private float thrust;
    /// <summary>
    /// Current wind velocity
    /// </summary>
    private Vector3 windVelocity = new Vector3(0, 0, 0);
    #endregion

    /// <summary>
    /// Cooldown period between shots
    /// </summary>
    private float LastFireTime = 0.0f;

    /// <summary>
    /// Initialize component
    /// </summary>
    internal void Start() {
        playerRB = GetComponent<Rigidbody>();
        playerRB.velocity = transform.forward*3;
    }

    /// <summary>
    /// Show game-over display
    /// </summary>
    /// <param name="safe">True if we won, false if we crashed</param>
    public void OnGameOver(bool safe) {
        var rigidBodies = FindObjectsOfType<Rigidbody>();
        foreach (var rb in rigidBodies)
        {
            rb.velocity = Vector3.zero;
            rb.useGravity = false;
            rb.constraints = RigidbodyConstraints.FreezeAll;
        }
        if (safe) {
            GameOverText.text = "You Win!";
        } else {
            GameOverText.text = "You Lose";
        }
    }

    /// <summary>
    /// Display status information
    /// </summary>
    internal void OnGUI()
    {
        StatusDisplay.text = string.Format("Speed: {0:00.00}    altitude: {1:00.00}    Thrust {2:0.0}",
            playerRB.velocity.magnitude,
            transform.position.y,
            thrust);
    }

    private void Update()
    {
        bool fireButton = Input.GetButton("Fire");
        if (fireButton && Time.time > LastFireTime + GunCoolDownTime)
        {
            LastFireTime = Time.time;
            Fire();
        }
    }

    private void Fire()
    {
        FireBullet(transform.position - transform.right / 2);
        FireBullet(transform.position + transform.right / 2);
    }

    private void FireBullet(Vector3 position)
    {
        Ray ray = Camera.main.ScreenPointToRay(new Vector2(Screen.width / 2, Screen.height / 2));
        var bulletPos = position + ray.direction * 5;
        var angles = transform.rotation.eulerAngles;
        angles.x += 90;
        var bullet = Instantiate(BulletPrefab, bulletPos, Quaternion.Euler(angles));
        bullet.GetComponent<Rigidbody>().velocity = BulletVelocity * ray.direction + playerRB.velocity;
    }

    private void FixedUpdate()
    {
        // Yaw, Pitch, Roll
        float rollInput = Input.GetAxis("Horizontal") * RollRange;
        float pitchInput = Input.GetAxis("Vertical") * PitchRange;

        roll = Mathf.Lerp(roll, rollInput, LerpWeight);
        pitch = Mathf.Lerp(pitch, pitchInput, LerpWeight); 
        

        yaw -= roll * RotationalSpeed * Time.fixedDeltaTime;
        playerRB.MoveRotation(Quaternion.Euler(pitch, yaw, roll));

        // Thrust
        thrust = Mathf.Max(0, Input.GetAxis("Thrust")) * MaximumThrust;
        var thrustForce = transform.forward * thrust;

        // Aerodynamics
        windVelocity = new Vector3(0, 0, 0);
        Vector3 playerMinusWindVelocity = playerRB.velocity - windVelocity;

        float vFwd = Vector3.Dot(playerMinusWindVelocity, transform.forward);
        float vUp = Vector3.Dot(playerMinusWindVelocity, transform.up);

        var fwdDragForce = -Mathf.Sign(vFwd) * transform.forward * ForwardDragCoefficient * Mathf.Pow(vFwd, 2);
        var upDragForce = -Mathf.Sign(vUp) * transform.up * VerticalDragCoefficient * Mathf.Pow(vUp, 2);
        var liftForce = transform.up * LiftCoefficient * Mathf.Pow(vFwd, 2);

        playerRB.AddForce(thrustForce + fwdDragForce + upDragForce + liftForce);            
    }

    private void OnCollisionEnter(Collision collision)
    {
        if (collision.collider.GetComponent<BulletBehavior>() == null)
        {
            // TODO: sounds and effects
            OnGameOver(false);
        }
    }
}
